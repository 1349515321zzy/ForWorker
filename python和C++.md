## 一Python知识点

​		sort()对自己排序，sorted()返回排序后的副本。

​		range（）函数说明：range(start, end[, step])。从start开始，包括start，不包括end

​		b=a   \# 引用，除非直接给a重新赋值，否则a变则b变，b变则a变

​		c = copy.copy(a)  # 浅复制，只会拷贝父对象， 不会拷贝父对象中的子对象，所以若a的子对象变则c 变,但是父对象变c不会变
​		d = copy.deepcopy(a) #深拷贝，完全拷贝，完全独立于原对象，a变也不变
​		a.append(5) # 改变父对象

​		a[4].append('c')  #改变父对象中的 ['a', 'b']子对象

python中的list、tuple、dict、set 

**1、list**

（1）构造list，使用[ ]把list的所有元素都括起来就是一个列表，用变量L表示。其中的元素不要求是同一种数据类型。 

（2）**列表中元素是有序的**。可以通过索引来访问。

（3）访问list的元素，L[0]：表示列表中的第一个元素，L[-1]：表示列表中的最后一个元素。 

​     L[起始索引:终止索引]：表示访问列表中的多个元素，包含头，不包含尾。 

（4）**列表是可以被修改的**，包括添加元素，删除元素，替换元素。 

1）添加元素：L.append(元素)、L.insert(元素插入到列表中的位置，元素) 

2）删除元素：L.pop()<==>L.pop(-1)，L.pop(要删除元素在列表中的位置)、L.remove(要删除元素)，删除列表中第一次匹配到的元素

3）替换元素：L[要替换元素在列表中的位置]=新的元素值 

（5）计算列表的长度：len(L) 

（6）计算列表中某一个元素在列表中出现的次数：L.count(要统计的元素) 

（7）列表拼接，用+，L1=[1,2],L2=[3,4],L1+L2=[1,2,3,4] 

（8）列表中元素复制，用*，L= [2,3],L*3 = [2,3,2,3,2,3] 

**2、tuple**

（1）构造tuple，使用（）把tuple的所有元素都括起来就是一个元组，用变量T表示。python规定只有单个元素的元组应表示成（元素，），避免歧义。其中的元素不要求是同一种数据类型。

（2）**元组中元素是有序的**。可以通过索引访问。

（3）访问tuple的元素，T[0]：表示元组中的第一个元素，T[-1]：表示元组中的最后一个元素。

（4）**元组是不可以被修改的**，因此它没有append（）、insert（）、pop（）等方法。

注意：元组中可以包含列表，如T= （1，2，[4，5]），

T[2] = [ ],错误

T[2][0] =5,正确 

**3、dict**

（1）构造dict，使用{ }把dict所有元素都括起来就是一个字典，用D表示。D中元素的形式是key：value的形式。其中的key或者value都不要求是

同一种数据类型。

（2）**字典中元素是无序的**。不可以通过索引访问。

（3）访问dict的元素，使用D[key]来查找对应的value。如果key不存在，则会报错。为避免报错： 

1）访问前先判断 

if key in D：

print（D[key]）

2）使用get()方法

print(D.get[key])，key不存在会输出None

（4）**字典是可以被修改的。**D[key] = 新的value，如果key不存在，则会想字典中添加这一键值对。 

注意： 

字典的一个最明显的特点是查找速度快，无论字典中有多少个数据，查找的速度都是一样的，因为它是按照key来查找的。但是它占用的内存大。典型的以空间换时间的思想。 

**4、set**

（1）构建set，S = set(传入一个列表)，或者S = {元素1，元素2，....}。其中的元素不要求是同一种数据类型。如： 

S= set（[1,2,3,3,4,5]） 

print(S) #{1,2,3,4,5}

注意：创建空集合只能使用S = set()，而不能使用S = { }，这是用来创建空字典的。 

（2）**集合中元素是无序的**。不可以通过索引来访问元素。 

（3）**集合是可以被修改的。**

（4）添加元素和删除元素。 

1）S.add(元素)

2）S.remove(元素)。删除之前要进行判断：if 元素 in S： S.remove(元素)，否则会报错。

### 1.python如何进行内存管理

​		垃圾回收机制：Python的垃圾回收机制采用引用计数机制为主，标记-清除和分代回收机制为辅的策略。其中，标记-清除机制用来解决计数引用带来的循环引用而无法释放内存的问题，分代回收机制是为提升垃圾回收的效率。

​		引用计数

​		 python采用了类似windows内核对象一样的方式来对内存进行管理。每一个对象，都维护这一个对指向该对象的引用的计数。当变量被绑定在一个对象上的时候，该变量的引用计数就是1，（还有另外一些情况也会导致变量引用计数的增加），系统会自动维护这些标签，并定时扫描，当某标签的引用计数变为0的时候，该对象就会被回收。

### 2、什么是可迭代对象？迭代器？

​		迭代是Python最强大的功能之一，是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。迭代器有两个基本的方法：**iter()** 和 **next()**。

​		实现了方法__iter__的对象是可迭代的，实现了方法__next__的对象是迭代器。通过对可迭代对象调用内置函数iter也可以实现一个迭代器。

### 3、列表生成式？

​		列表生成式是一个可以生成列表的特定语法形式的表达式。可以帮助我们把一个序列或者其他可迭代类型的中的元素过滤或者加工，然后在新建一个列表。

### 4、装饰器

​		装饰器的作用就是为已经存在的对象添加新的功能。是一种函数的函数，因为装饰器传入的参数就是一个函数，然后通过实现各种功能来对这个函数的功能进行增强。然后把它返回，装饰器是可调用对象。常用于计算函数运行时间、给函数打日志、类型检查

​		装饰器的一大特点是：能把被装饰的函数替换成其他函数，装饰器在加载模块时立即执行，让代码更简洁。 

​		不修改被装饰的函数的源代码，不修改被装饰的函数的调用方式的情况下给程序增添功能。

​		python的@property是python的一种装饰器，是用来修饰方法的，来创建**只读属性**，会将方法转换为相同名称的**只读属性**，*加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）*，添加 `@property` 后，这个方法就变成了一个属性

### 5、进程、线程和协程的区别

一、概念
1、进程：进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程间通过进程间通信来通信。
2、线程：是CPU调度和分配一个基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要靠内存，上下文切换很快，资源开销较少，但比进程不够稳定容易丢失数据。
3、协程：协程是一种用户态的轻量级线程，协程的调度完全由用户控制。

二、区别与联系
1、进程与线程比较
线程是进程内的一个执行单位，也是进程内可调度实体。区别：
1）地址空间：线程是进程内的一个执行单元，进程内至少有一个线程，他们共享进程的地址空间，而进程有自己独立的地址空间。
2）资源拥有：进程是资源分配和拥有的单位，同一进程内的线程共享进程的资源。
3）线程是处理器调度的基本单位，但进程是系统调度。
4）二者都是处理多任务的方法，均可并发执行。
5）每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口吗，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

2、协程和线程的比较
1）一个线程可以有多个协程，一个进程也可以单独拥有多个协程。
2）线程进程都是同步机制，而协程是异步
3）协程能保留上一次调用时的状态，每次过程重入时，就相当于上一次调用的状态。



通信方式：线程：**共享内存**、**消息传递**和**管道流**

进程：管道、消息队列、信号量、信号、共享内存、Socket

### 6.del、remove、pop的区别

del根据位置删除元素，不返回任何值
pop根据位置弹出元素，没有参数就从数组末尾弹出元素，返回的是数组
remove根据值删除元素，默认删除从左到右第一个元素

### 7、python的内存池机制

​		在Python中，许多时候申请的内存都是小块的内存，这些小块内存在申请后，很快又会被释放，由于这些内存的申请并不是为了创建对象，所以并没有对象一级的内存池机制。这就意味着Python在运行期间会大量地执行malloc和free的操作，频繁地在用户态和核心态之间进行切换，这将严重影响Python的执行效率。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。
​		Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统

### 8、深拷贝和浅拷贝的区别

深拷贝和浅拷贝都是对象的拷贝，都会生成一个看起来相同的对象，他们本质的却别是拷贝出来的对象的地址是否是核原对象一样，也就是是地址的的复制还是值的复制。

浅拷贝拷贝的是原对象的引用，新对象和原对象还是指向内存中同一块空间，原对象的值发生改变，会影响新对象的值。三种形式：切片操作，工厂函数，copy模块中的copy函数

深拷贝是再遇到可变对象，是在内部新建了一个副本，对象的值和地址都不一样，**不再与原来的对象有任何关联。**

### 9、map，filter， reduce，apply

filter
功能： filter的功能是过滤掉序列中不符合函数条件的元素，当序列中要删减的元素可以用某些函数描述时，就应该想起filter函数。
调用： filter（function，sequence），function可以是匿名函数或者自定义函数，它会对后面的sequence序列的每个元素判定是否符合函数条件，返回TRUE或者FALSE，从而只留下TRUE的元素；sequence可以是列表、元组或者字符串

map
功能： 求一个序列或者多个序列进行函数映射之后的值，就该想到map这个函数，它是python自带的函数，在python3.*之后返回的是迭代器，同filter，需要进行列表转换
调用： map(function,iterable1,iterable2)，function中的参数值不一定是一个x，也可以是x和y，甚至多个；后面的iterable表示需要参与function运算中的参数值，有几个参数值就传入几个iterable。

reduce
功能： 对一个序列进行压缩运算，得到一个值。但是reduce在python2的时候是内置函数，到了python3移到了functools模块，所以使用之前需要 from functools import reduce
调用： reduce（function，iterable），其中function必须传入两个参数，iterable可以是列表或者元组

### 10、GIL线性全局锁

线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制，就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。

解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).

### 11、__new__和__init__的区别

__new__是一个静态方法，而__init__是一个实例方法；
__new__方法会返回一个创建的实例，而__init__什么都不返回；
只有在__new__返回一个cls的实例时，后面的__init__才不能被调用；
当创建一个新实例时调用__new__，初始化一个实例时用__init__

### 12、闭包

​		闭包是指延伸了作用域的函数，其中包含函数定义体中引用不在定义体中定义的非全局变量。也就是说闭包可以访问定义体之外的定义的非全局变量。

​		闭包只有在使用嵌套函数时使用，闭包是一个保留定义函数时存在的自由变量的绑定，虽然作用域不可用了，但是仍能使用这些绑定。

### 13、*arg、**kargs的用法？

*args是可变参数，args接受的是一个元组，**kargs是关键字参数，接受的是一个字典。

### 14、python的基本数据类型？

Number(数字）、String（字符串）、List（列表）、Tuple（元组）、set（集合）、Dict（字典）
不可变对象有：数值类型，int ，float，字符串，元组
可变对象：列表，字典，集合
可变对象：对象所指的值可以改变，改变时，值指向的内存单元不变，还是指向原来的地址，没有新开辟一块内存。
不可变对象：对象所指向的内存中的值不能被改变，当改变这个变量的时候，原来指向的内存中的值不变，变量不再指向原来的值，而是开辟一块新的内存，变量指向新的内存。

### 15、值传递和索引传递

​		顾名思义，所谓值传递就是指在传递过程中将实际参数的值复制一份传递给形式参数，这样即使在函数执行过程中对形式参数进行了修改，实际参数也不会有所改变，因为二者互不干扰。而引用传递是值将实际参数的引用传递给实际参数，这样二者就会指向同一块内存地址，在函数执行过程中对形式参数进行了修改，实际参数也会一并=被修改。

### 16、lambda函数

​		匿名函数，减少了代码的冗余，不用费神思考一个函数的名字，lambda函数使代码的可读性更强，程序看起来更加简洁。可以直接赋给一个变量，然后再像一般函数那样调用；将lambda函数作为参数传递给其他函数比如说结合map。

### 17、callable

​		一个可callable的对象是指可以被调用执行的对象，并且可以传入参数，只要可以在一个对象的后面使用小括号来执行代码，那么这个对象就是callable对象。函数、类、类里的函数、实现了__call__方法的实例对象

### 18、查询效率分析set、dict

​		set>dict>list

​		list 就是O(n)的；而set做了去重，本质应该一颗红黑树（猜测，STL就是红黑树），复杂度O(logn)；dict类似对key进行了hash,然后再对hash生成一个红黑树进行查找，其查找复杂其实是O(logn)

### 19、生成器

​		生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。Python使用生成器对延迟操作提供了支持。所谓延迟操作，是指在需要的时候才产生结果，而不是立即产生结果。这也是生成器的主要好处。生成器自动实现了迭代器协议

​		在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象。

1. **生成器函数：**常规函数定义，但是，使用yield语句而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次从它离开的地方继续执行
2. **生成器表达式：**类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表

### 20、变量作用域

L：local，局部作用域，即函数中定义的变量；
E：enclosing，嵌套的父级函数的局部作用域，即包含此函数的上级函数的局部作用域，但不是全局的；
G：globa，全局变量，就是模块级别定义的变量

B：built-in，系统固定模块里面的变量，比如int, bytearray等

 		搜索变量的优先级顺序依次是：作用域局部>外层作用域>当前模块中的全局>python内置作用域，也就是LEGB

### 21、List的实习方式

​		Cpython是python最常用的实现，在CPython中列表List是通过C语言的结构体（structure）来表示，ob_item是指向列表元素的指针列表，allocated是在内存中分配的插槽数

### 22、实例方法、静态方法和类方法

​		实例方法只能被实例对象调用，第一个参数必须要默认传实例对象，一般习惯用self。

​		静态方法(由@staticmethod装饰的方法)，参数没有要求，可以被类或类的实例对象调用，静态方法无需实例化也可直接调用

​		类方法(由@classmethod装饰的方法)，第一个参数必须要默认传类，一般习惯用cls，可以被类或类的实例对象调用。**类方法可以模拟java定义多个构造函数的情况**

​		如果子类继承父类的方法，子类覆盖了父类的静态方法，
​		子类的实例继承了父类的static_method静态方法，调用该方法，还是调用的父类的方法和类属性。
​		子类的实例继承了父类的class_method类方法，调用该方法，调用的是子类的方法和子类的类属性。

### 24、 [0]*n

​		[ 0 ] * n 是浅拷贝， 也就是把一个列表重复了 n 次，是 = 号复制（注意不是浅拷贝，= 与浅拷贝的list id是不同的）；[[0]*n]*m 这种方式是直接将 [0]*n 复制了m遍

​		[0 for _ in range(n)] 才是创建，深拷贝

### 25、python代码加速

​		1.避免使用全局变量，**用for循环代替while循环s		避免数据复制：交换值时不使用中间变量， 避免无意义的数据复制，字符串拼接用join而不是+

**

​		当使用a + b拼接字符串时，由于 Python 中字符串是不可变对象，其会申请一块内存空间，将a和b分别复制到该新申请的内存空间中。因此，如果要拼接 个字符串，会产生 个中间结果，每产生一个中间结果都需要申请和复制一次内存，严重影响运行效率。而使用join()拼接字符串时，会首先计算出需要申请的总的内存空间，然后一次性地申请所需内存，并将每个字符串元素复制到该内存中去。

### 26、python字典和集合的底层实现

​		字典是通过哈希表实现的。字典也被称为关联数组，还称为哈希数组等。字典也是一个数组，但数组的索引是键经过哈希函数处理后得到的散列值。哈希函数的目的是使键均匀地分布在数组中，并且可以在内存中以O(1)的时间复杂度进行寻址，从而实现快速查找和修改。

​		哈希表中哈希函数的设计困难在于将数据均匀分布在哈希表中，从而尽量减少哈希碰撞和冲突。由于不同的键可能具有相同的哈希值，即可能出现冲突，高级的哈希函数能够使冲突数目最小化。Python中并不包含这样高级的哈希函数，几个重要（用于处理字符串和整数）的哈希函数是常见的几个类型。通常情况下建立哈希表的具体过程如下：

​		数据添加：把key通过哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。
​		数据查询：再次使用哈希函数将key转换为对应的数组下标，并定位到数组的位置获取value。
哈希函数就是一个映射，因此哈希函数的设定很灵活，只要使得任何关键字由此所得的哈希函数值都落在表长允许的范围之内即可。本质上看哈希函数不可能做成一个一对一的映射关系，其本质是一个多对一的映射，这也就引出了下面一个概念–哈希冲突或者说哈希碰撞。哈希碰撞是不可避免的，但是一个好的哈希函数的设计需要尽量避免哈希碰撞。

链接法、开放地址法解决冲突。

### 27、__call__函数

​		_call__实际上是将一个类重载了"()"，也就是让一个类也可以像一个函数一样可以拿来调用了。类实例化后，可以直接调用call函数，执行的是call函数的代码。

### 28、Python 将一个列表里面的元素拼接成一个字符串

​		join() 方法描述：将序列（列表或元组）中的元素以指定的字符连接成一个新的字符串。

### 29、python中字典的key要求

		有__hash__方法可以做字典的key，没有则不能作为字典的key;

   除了list、dict、set和内部至少带有上述三种类型之一的tuple之外，其余对象均可作为字典的key；
### 30、pyhton的 is 和 == 有什么区别？python的class在继承父类时，super的作用是什么
is判断是不是同一个变量，==判断变量的值是否相等。super() 函数是用于调用父类(超类)的一个方法。super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题
### 31 self？
在类中定义函数只有一点不同，就是第一参数永远是类的本身实例变量self，并且调用时，不用传递该参数。
## 二、C++

​		1.当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动初始化。

### 1.左值与右值

- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

### 2.指针与引用的区别

1) 引用必须被初始化，指针不必。

2) 引用初始化以后不能被改变，指针可以改变所指的对象。

3) 不存在指向空值的引用，但是存在指向空值的指针。

4、引用的创建和销毁不会调用类的拷贝构造函数和析构函数。

### 3.堆与栈的区别

​		栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。

​		其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，相邻变量的地址之间不会存在其它变量。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量。栈中存储的数据的生命周期随着函数的执行完成而结束。

​		堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。生命周期等同于程序的生命周期。

### 1.3 堆与栈区别

堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：
（1）管理方式不同。栈由操作系统自动分配释放；堆的申请和释放需要手动控制，容易产生内存泄漏；

（2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。

（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。

（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。

​	堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。

​		堆分配空间灵活，分配大量的内存空间，需要用堆。



### 5.new与malloc的区别

（1） new、delete 是操作符，可以重载，只能在 C++中使用。
（2） malloc、free 是函数，可以覆盖，C、C++中都可以使用。
（3） new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。
（4） malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数
（5）成功返回类型： new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。

最大的区别：new在申请空间的时候会调用构造函数，malloc不会调用



### 6.C++与java的区别

1.变量类型

​		1.1 Java没有无符号整数。（无符号右移在Java中强制用三个右尖括号表示）。
​		1.2 Java有内置类型String，而C++没有。C++的std::string是可变的，类似于Java的StringBuffer。
​		1.3 C++的整型随机器的位数而变化，但是Java不会。（C++的int在16位机器上16位，32位级以上为		32位。long在32位及以下为32位，64位机器上为64位。）
​		1.4 Java字符串在内存中以Unicode存储，C++与源码的编码相同。
​		1.5 Java中不存在指针。Java的引用是功能弱化的指针，只能做“调用所指对象的方法”的操

2.类机制

​		2.1 Java是完全面向对象的，所有方法都必须写在类中。
2.2 Java强制异常规约。
2.3 Java单根继承，所有对象都继承自Object。并且提供接口机制。
2.4 Java在覆盖时默认为虚函数。
2.5 Java没有默认参数。
2.6 Java中没有运算符重载，和转换函数。
2.7 Java无引用传值

3. 其它语言特性

   3.1 Java没有delete运算符，由于有gc托管，无需delete。
   3.2 Java没有typedef，以及任何和它作用相同的语法。
   3.3 Java没有宏。（另一方面这也是种好处，宏是另一个万恶之源）。



### **7.strcut和class的区别**

> **1.默认的继承访问权。class默认的是private,strcut默认的是public。**
> **2.默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。**
> **3.“class”这个关键字还用于定义模板参数，就像“typename”。但关建字“struct”不用于定义模板参数**

> **4.class和struct在使用大括号{ }上的区别**
> **关于使用大括号初始化**
> **1.）class和struct如果定义了构造函数的话，都不能用大括号进行初始化**
> 　　**2.）如果没有定义构造函数，struct可以用大括号初始化。**
> 　　**3.）如果没有定义构造函数，且所有成员变量全是public的话，class可以用大括号初始化**



### 8.#define和const的区别

1）#define定义的常量没有类型，所给出的是一个立即数；const定义的常量有类型名字，存放在静态区域

2）处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝。

3）#define定义的常量是不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址

4）#define可以定义简单的函数，const不可以定义函数

### **9、C++文件编译与执行的四个阶段**

1）预处理：根据文件中的预处理指令来修改源文件的内容

2）编译：编译成汇编代码

3）汇编：把汇编代码翻译成目标机器指令

4）链接：链接目标代码生成可执行程序

### 10、虚函数的作用

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数

### 11、vector底层实现

​		每个动态数组都分配有一定容量，当存储的数据达到容量的上限的时候，就重新分配内存，resize函数，重新分配空间，在堆区新开辟内存，然后将以前数组的值赋给他，删除以前的数组

### 12、sort函数底层实现

​		数据量大时采用快速排序 Quick Sort，分段递归排序。一旦分段后的数据量小于某个阈值，为避免Quick Sort的递归调用带来过大的额外开销，就改用插入排序 Insertion Sort。如果递归层次过深，还会改用堆排序 Heap Sort

### 13、多态是什么

​			多态性可以简单地概括为“一个接口，多种方法”，C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写

### 14、智能指针

### 15、析构函数

1. 作用：对象消亡时，自动被调用，用来释放对象占用的空间

2.特点:
  (1) 名字与类名相同
  (2) 在前面需要加上"~"
  (3) 无参数，无返回值
  (4) 一个类最多只有一个析构函数
  (5) 不显示定义析构函数会调用缺省析构函数

### 16、C++构造函数

1、无参数构造函数

2、有参数构造函数

3、赋值构造函数（copy构造函数 ）

4、默认构造函数

长尾分布。机器智能部，风控模型。



## 三、面经题

 1.某疾病发病概率1/1000，患者有95%的概率检测出患病，健康者有5%的概率被误诊，问若一个人被检测出患病，实际患病概率是多少。

​			将真的患病且被诊断出来概率除以诊断出来患病的概率 P=0.1%*95%/(0.1%*95%+99.9%*5%)

### 2.外部排序算法



## 四、linux命令

### 1.grep 

查找文件里符合条件的字符串。指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来

### 2sed

sed 命令是利用脚本来处理文本文件。

sed 可依照脚本的指令来处理、编辑文本文件。

Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。

### 3.pwck

使用pwck命令用来验证系统认证文件/etc/passwd和/etc/shadow的内容和格式的完整性。

### 4、top、free、ps

​		top命令可以查看CPU、内存利用率； free命令查看总内存、使用、空闲等情况

​		ps（process status）命令用来汇报处理器状态信息

### 5、du

​		du -h ：查看当前目录及子目录的大小。

​		-a：显示目录占用的磁盘空间大小，还要显示其下目录和文件占用磁盘空间的大小

　　-s：显示目录占用的磁盘空间大小，不要显示其下子目录和文件占用的磁盘空间大小

## 五智力题

### 1.时针和分针一天重合多少次

时针和分针每天会重合22次。

可用一个方程解得：时针每小时走30°，分针每小时360°，二者转角差360°的整数倍时重合，则360h-30h=360n (h代表时间 0<h≤24，n代表重合次数，取整数)。可知n≤22，此时两指针重合在24点位置。



### 2.平均要抛多少次硬币，才能出现连续两次正面向上？

​		首先设连续两次正面的期望次数为x。1次正面的期望次数易得，为2。

​		接下来有1/2的概率再出来一个正面，这时总期望次数为2+1
​		有1/2的概率再出来一个反面，这时总期望次数为2+1+x

​		所以x=1/2 * (2+1) + 1/2 * (2+1+x)
​		解得x=6

### 3.一个圆任取3个点,求三点构成的三角形为锐角三角形的概率是多少?

​		在圆上任取一点A,A做直径m与垂直m的直径n（即将圆四等分）.假设分为1,2,3,4四部分.另两点A,B只有在相对部分（即1,3或2,4）才可使三角形ABC为锐角三角形或直角三角形.不难算出其概率为0.25

### 4.斐波那契数列取模

​	1e9+7

### 5、On计算方差

​		D（X）=E（X^2）-[E(X)^2]         方差公式的变形  （x^2+x^2）/n + (x+x)^2/n

### 6、3局2胜和5局3胜哪个胜算更大

​			对水平高的一方，采用局数越多的决胜方式，胜算越大。

### 7、药丸称重

	   有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。
​		可以从药丸的数量上来制造差异：从第 i 瓶药丸中取出 i 个药丸，然后一起称重。可以知道，如果第 i 瓶药丸重 1.1 克/粒，那么称重结果就会比正常情况下重 0.1 * i 克。


### 8、拿到最后一本书

		100本书，两个人轮流拿，每次拿1~5本，你先拿，有没有啥策略可以保证你可以拿到最后一本？
​		要想拿到最后的书，则最后要剩下6本，则前面要拿94本书，这样无论对方怎么拿，我都能拿到最后的书
​		对方每次拿1-5 之前的N本书，所以我可以每次拿6-N本，保证我俩每次拿的书之和相加 = 6
​		94/6 取余 = 4，所以要先拿 4本，其余的只要保证相加为6就行了

### 9、疯狗问题

①疯狗有一只->若第一天自己没有看到疯狗->自己家的狗是疯狗->枪声响在第一天。

②疯狗有两只->自己第一天看到一只疯狗->第一天枪声没响->按照逻辑①，如果只有一只疯狗，有人没看到疯狗，枪声一定会响->别人看到了疯狗，疯狗不止一只->自家的狗是疯狗->枪声响在第二天。

③疯狗有三只->自己第一天看到两只疯狗->按照逻辑②，枪声会响在第二天->第二天晚上没有枪响->疯狗数量>2->自家的狗是疯狗->枪声响在第三天。

根据上述逻辑推理，有N只疯狗，则枪声会响在第N天。

### 10、从10G个整数中找出中位数

### 11、30分钟内看到一辆车的概率是0.95，求10分钟内看到一辆车的概率

		设10分钟内没有看到一辆车的概率为1-x，30分钟内没有看到一辆车看作连续事件
( 1 − x ) × ( 1 − x ) × ( 1 − x ) = 1 − 0.95  

​	 x= 1- sqrt3(0.05)



## 六计算机基础

### 1、http与https的区别

​		超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息

​		安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

​		 HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全

​    	HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

		  1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
	
	    2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。
	
	    3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
	
	    4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
### 2、乐观锁/悲观锁

​		**何为乐观锁与悲观锁？**

答：乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

**乐观锁**：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。

因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。

**悲观锁**：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。

因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

